{"ast":null,"code":"import { process } from 'std-env';\nimport { lookup } from '@uploadthing/mime-types';\nfunction isRouteArray(routeConfig) {\n  return Array.isArray(routeConfig);\n}\nfunction getDefaultSizeForType(fileType) {\n  if (fileType === \"image\") return \"4MB\";\n  if (fileType === \"video\") return \"16MB\";\n  if (fileType === \"audio\") return \"8MB\";\n  if (fileType === \"blob\") return \"8MB\";\n  if (fileType === \"pdf\") return \"4MB\";\n  if (fileType === \"text\") return \"64KB\";\n  return \"4MB\";\n}\n/**\n * This function takes in the user's input and \"upscales\" it to a full config\n *\n * Example:\n * ```ts\n * [\"image\"] => { image: { maxFileSize: \"4MB\", limit: 1 } }\n * ```\n */\nfunction fillInputRouteConfig(routeConfig) {\n  // If array, apply defaults\n  if (isRouteArray(routeConfig)) {\n    return routeConfig.reduce((acc, fileType) => {\n      acc[fileType] = {\n        // Apply defaults\n        maxFileSize: getDefaultSizeForType(fileType),\n        maxFileCount: 1,\n        minFileCount: 1,\n        contentDisposition: \"inline\"\n      };\n      return acc;\n    }, {});\n  }\n  // Backfill defaults onto config\n  const newConfig = {};\n  const inputKeys = objectKeys(routeConfig);\n  inputKeys.forEach(key => {\n    const value = routeConfig[key];\n    if (!value) throw new Error(\"Invalid config during fill\");\n    const defaultValues = {\n      maxFileSize: getDefaultSizeForType(key),\n      maxFileCount: 1,\n      minFileCount: 1,\n      contentDisposition: \"inline\"\n    };\n    newConfig[key] = {\n      ...defaultValues,\n      ...value\n    };\n  }, {});\n  return newConfig;\n}\nfunction getTypeFromFileName(fileName, allowedTypes) {\n  const mimeType = lookup(fileName);\n  if (!mimeType) {\n    if (allowedTypes.includes(\"blob\")) return \"blob\";\n    throw new Error(`Could not determine type for ${fileName}, presigned URL generation failed`);\n  }\n  // If the user has specified a specific mime type, use that\n  if (allowedTypes.some(type => type.includes(\"/\"))) {\n    if (allowedTypes.includes(mimeType)) {\n      return mimeType;\n    }\n  }\n  // Otherwise, we have a \"magic\" type eg. \"image\" or \"video\"\n  const type = mimeType.toLowerCase() === \"application/pdf\" ? \"pdf\" : mimeType.split(\"/\")[0];\n  if (!allowedTypes.includes(type)) {\n    // Blob is a catch-all for any file type not explicitly supported\n    if (allowedTypes.includes(\"blob\")) {\n      return \"blob\";\n    } else {\n      throw new Error(`File type ${type} not allowed for ${fileName}`);\n    }\n  }\n  return type;\n}\nfunction generateUploadThingURL(path) {\n  let host = \"https://uploadthing.com\";\n  if (process.env.CUSTOM_INFRA_URL) {\n    host = process.env.CUSTOM_INFRA_URL;\n  }\n  return `${host}${path}`;\n}\n/**\n * RETURN UNDEFINED TO KEEP GOING\n * SO MAKE SURE YOUR FUNCTION RETURNS SOMETHING\n * OTHERWISE IT'S AN IMPLICIT UNDEFINED AND WILL CAUSE\n * AN INFINITE LOOP\n */\nconst withExponentialBackoff = async (doTheThing, MAXIMUM_BACKOFF_MS = 64 * 1000, MAX_RETRIES = 20) => {\n  let tries = 0;\n  let backoffMs = 500;\n  let backoffFuzzMs = 0;\n  let result = undefined;\n  while (tries <= MAX_RETRIES) {\n    result = await doTheThing();\n    if (result !== undefined) return result;\n    tries += 1;\n    backoffMs = Math.min(MAXIMUM_BACKOFF_MS, backoffMs * 2);\n    backoffFuzzMs = Math.floor(Math.random() * 500);\n    if (tries > 3) {\n      console.error(`[UT] Call unsuccessful after ${tries} tries. Retrying in ${Math.floor(backoffMs / 1000)} seconds...`);\n    }\n    await new Promise(r => setTimeout(r, backoffMs + backoffFuzzMs));\n  }\n  return null;\n};\nasync function pollForFileData(opts, callback) {\n  return withExponentialBackoff(async () => {\n    const res = await opts.fetch(opts.url, {\n      headers: {\n        ...(opts.apiKey && {\n          \"x-uploadthing-api-key\": opts.apiKey\n        }),\n        \"x-uploadthing-version\": opts.sdkVersion\n      }\n    });\n    const maybeJson = await safeParseJSON(res);\n    if (maybeJson instanceof Error) {\n      console.error(`[UT] Error polling for file data for ${opts.url}: ${maybeJson.message}`);\n      return null;\n    }\n    if (maybeJson.status !== \"done\") return undefined;\n    await callback?.(maybeJson);\n    return Symbol(\"backoff done without response\");\n  });\n}\nconst FILESIZE_UNITS = [\"B\", \"KB\", \"MB\", \"GB\"];\nconst fileSizeToBytes = input => {\n  const regex = new RegExp(`^(\\\\d+)(\\\\.\\\\d+)?\\\\s*(${FILESIZE_UNITS.join(\"|\")})$`, \"i\");\n  const match = input.match(regex);\n  if (!match) {\n    return new Error(\"Invalid file size format\");\n  }\n  const sizeValue = parseFloat(match[1]);\n  const sizeUnit = match[3].toUpperCase();\n  if (!FILESIZE_UNITS.includes(sizeUnit)) {\n    throw new Error(\"Invalid file size unit\");\n  }\n  const bytes = sizeValue * Math.pow(1024, FILESIZE_UNITS.indexOf(sizeUnit));\n  return Math.floor(bytes);\n};\nasync function safeParseJSON(input) {\n  if (typeof input === \"string\") {\n    try {\n      return JSON.parse(input);\n    } catch (err) {\n      console.error(`Error parsing JSON, got '${input}'`);\n      return new Error(`Error parsing JSON, got '${input}'`);\n    }\n  }\n  const text = await input.text();\n  try {\n    return JSON.parse(text ?? \"null\");\n  } catch (err) {\n    console.error(`Error parsing JSON, got '${text}'`);\n    return new Error(`Error parsing JSON, got '${text}'`);\n  }\n}\n/** typesafe Object.keys */\nfunction objectKeys(obj) {\n  return Object.keys(obj);\n}\n/** checks if obj is a valid, non-null object */\nfunction isObject(obj) {\n  return typeof obj === \"object\" && obj !== null && !Array.isArray(obj);\n}\nfunction asArray(val) {\n  return Array.isArray(val) ? val : [val];\n}\n/** construct content-disposition header */\nfunction contentDisposition(contentDisposition, fileName) {\n  return [contentDisposition, `filename=\"${encodeURI(fileName)}\"`, `filename*=UTF-8''${encodeURI(fileName)}`].join(\"; \");\n}\nfunction semverLite(required, toCheck) {\n  // Pull out numbers from strings like `6.0.0`, `^6.4`, `~6.4.0`\n  const semverRegex = /(\\d+)\\.?(\\d+)?\\.?(\\d+)?/;\n  const requiredMatch = required.match(semverRegex);\n  if (!requiredMatch?.[0]) {\n    throw new Error(`Invalid semver requirement: ${required}`);\n  }\n  const toCheckMatch = toCheck.match(semverRegex);\n  if (!toCheckMatch?.[0]) {\n    throw new Error(`Invalid semver to check: ${toCheck}`);\n  }\n  const [_1, rMajor, rMinor, rPatch] = requiredMatch;\n  const [_2, cMajor, cMinor, cPatch] = toCheckMatch;\n  if (required.startsWith(\"^\")) {\n    // Major must be equal, minor must be greater or equal\n    if (rMajor !== cMajor) return false;\n    if (rMinor > cMinor) return false;\n    return true;\n  }\n  if (required.startsWith(\"~\")) {\n    // Major must be equal, minor must be equal\n    if (rMajor !== cMajor) return false;\n    if (rMinor !== cMinor) return false;\n    return true;\n  }\n  // Exact match\n  return rMajor === cMajor && rMinor === cMinor && rPatch === cPatch;\n}\nfunction getFullApiUrl(maybeUrl) {\n  const base = (() => {\n    if (typeof window !== \"undefined\") return window.location.origin;\n    if (process.env?.VERCEL_URL) return `https://${process.env.VERCEL_URL}`;\n    return \"http://localhost:3000\";\n  })();\n  try {\n    const url = new URL(maybeUrl ?? \"/api/uploadthing\", base);\n    if (url.pathname === \"/\") {\n      url.pathname = \"/api/uploadthing\";\n    }\n    return url;\n  } catch (err) {\n    throw new Error(`Failed to parse '${maybeUrl}' as a URL. Make sure it's a valid URL or path`);\n  }\n}\n/*\n * Returns a full URL to the dev's uploadthing endpoint\n * Can take either an origin, or a pathname, or a full URL\n * and will return the \"closest\" url matching the default\n * `<VERCEL_URL || localhost>/api/uploadthing`\n */\nfunction resolveMaybeUrlArg(maybeUrl) {\n  return maybeUrl instanceof URL ? maybeUrl : getFullApiUrl(maybeUrl);\n}\nconst ALLOWED_FILE_TYPES = [\"image\", \"video\", \"audio\", \"pdf\", \"text\", \"blob\"];\nconst ERROR_CODES = {\n  // Generic\n  BAD_REQUEST: 400,\n  NOT_FOUND: 404,\n  FORBIDDEN: 403,\n  INTERNAL_SERVER_ERROR: 500,\n  INTERNAL_CLIENT_ERROR: 500,\n  // S3 specific\n  TOO_LARGE: 413,\n  TOO_SMALL: 400,\n  TOO_MANY_FILES: 400,\n  KEY_TOO_LONG: 400,\n  // UploadThing specific\n  URL_GENERATION_FAILED: 500,\n  UPLOAD_FAILED: 500,\n  MISSING_ENV: 500,\n  FILE_LIMIT_EXCEEDED: 500\n};\nfunction messageFromUnknown(cause, fallback) {\n  if (typeof cause === \"string\") {\n    return cause;\n  }\n  if (cause instanceof Error) {\n    return cause.message;\n  }\n  if (cause && typeof cause === \"object\" && \"message\" in cause && typeof cause.message === \"string\") {\n    return cause.message;\n  }\n  return fallback ?? \"An unknown error occurred\";\n}\nclass UploadThingError extends Error {\n  constructor(initOpts) {\n    const opts = typeof initOpts === \"string\" ? {\n      code: \"INTERNAL_SERVER_ERROR\",\n      message: initOpts\n    } : initOpts;\n    const message = opts.message ?? messageFromUnknown(opts.cause, opts.code);\n    super(message);\n    this.code = opts.code;\n    this.data = opts.data;\n    if (opts.cause instanceof Error) {\n      this.cause = opts.cause;\n    } else if (opts.cause instanceof Response) {\n      this.cause = new Error(`Response ${opts.cause.status} ${opts.cause.statusText}`);\n    } else if (typeof opts.cause === \"string\") {\n      this.cause = new Error(opts.cause);\n    } else {\n      this.cause = opts.cause;\n    }\n  }\n  static async fromResponse(response) {\n    const jsonOrError = await safeParseJSON(response);\n    if (jsonOrError instanceof Error) {\n      return new UploadThingError({\n        message: jsonOrError.message,\n        code: getErrorTypeFromStatusCode(response.status),\n        cause: response\n      });\n    }\n    let message = undefined;\n    if (isObject(jsonOrError)) {\n      if (typeof jsonOrError.message === \"string\") {\n        message = jsonOrError.message;\n      } else if (typeof jsonOrError.error === \"string\") {\n        message = jsonOrError.error;\n      }\n    }\n    return new UploadThingError({\n      message,\n      code: getErrorTypeFromStatusCode(response.status),\n      cause: response,\n      data: jsonOrError\n    });\n  }\n  static toObject(error) {\n    return {\n      code: error.code,\n      message: error.message,\n      data: error.data\n    };\n  }\n  static serialize(error) {\n    return JSON.stringify(UploadThingError.toObject(error));\n  }\n}\nfunction getStatusCodeFromError(error) {\n  return ERROR_CODES[error.code] ?? 500;\n}\nfunction getErrorTypeFromStatusCode(statusCode) {\n  for (const [code, status] of Object.entries(ERROR_CODES)) {\n    if (status === statusCode) {\n      return code;\n    }\n  }\n  return \"INTERNAL_SERVER_ERROR\";\n}\nconst INTERNAL_DO_NOT_USE__fatalClientError = e => new UploadThingError({\n  code: \"INTERNAL_CLIENT_ERROR\",\n  message: \"Something went wrong. Please report this to UploadThing.\",\n  cause: e\n});\nconst generateMimeTypes = fileTypes => {\n  const accepted = fileTypes.map(type => {\n    if (type === \"blob\") return \"blob\";\n    if (type === \"pdf\") return \"application/pdf\";\n    if (type.includes(\"/\")) return type;else return `${type}/*`;\n  });\n  if (accepted.includes(\"blob\")) {\n    return undefined;\n  }\n  return accepted;\n};\nconst generateClientDropzoneAccept = fileTypes => {\n  const mimeTypes = generateMimeTypes(fileTypes);\n  if (!mimeTypes) return undefined;\n  return Object.fromEntries(mimeTypes.map(type => [type, []]));\n};\n/**\n * Shared helpers for our premade components that's reusable by multiple frameworks\n */\nconst generatePermittedFileTypes = config => {\n  const fileTypes = config ? objectKeys(config) : [];\n  const maxFileCount = config ? Object.values(config).map(v => v.maxFileCount) : [];\n  return {\n    fileTypes,\n    multiple: maxFileCount.some(v => v && v > 1)\n  };\n};\nconst capitalizeStart = str => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\nconst INTERNAL_doFormatting = config => {\n  if (!config) return \"\";\n  const allowedTypes = objectKeys(config);\n  const formattedTypes = allowedTypes.map(f => f === \"blob\" ? \"file\" : f);\n  // Format multi-type uploader label as \"Supports videos, images and files\";\n  if (formattedTypes.length > 1) {\n    const lastType = formattedTypes.pop();\n    return `${formattedTypes.join(\"s, \")} and ${lastType}s`;\n  }\n  // Single type uploader label\n  const key = allowedTypes[0];\n  const formattedKey = formattedTypes[0];\n  const {\n    maxFileSize,\n    maxFileCount,\n    minFileCount\n  } = config[key];\n  if (maxFileCount && maxFileCount > 1) {\n    if (minFileCount > 1) {\n      return `${minFileCount} - ${maxFileCount} ${formattedKey}s up to ${maxFileSize}`;\n    } else {\n      return `${formattedKey}s up to ${maxFileSize}, max ${maxFileCount}`;\n    }\n  } else {\n    return `${formattedKey} (${maxFileSize})`;\n  }\n};\nconst allowedContentTextLabelGenerator = config => {\n  return capitalizeStart(INTERNAL_doFormatting(config));\n};\nconst styleFieldToClassName = (styleField, args) => {\n  if (typeof styleField === \"string\") return styleField;\n  if (typeof styleField === \"function\") {\n    const result = styleField(args);\n    if (typeof result === \"string\") return result;\n  }\n  return \"\";\n};\nconst styleFieldToCssObject = (styleField, args) => {\n  if (typeof styleField === \"object\") return styleField;\n  if (typeof styleField === \"function\") {\n    const result = styleField(args);\n    if (typeof result === \"object\") return result;\n  }\n  return {};\n};\nconst contentFieldToContent = (contentField, arg) => {\n  if (!contentField) return null;\n  if (typeof contentField !== \"function\") return contentField;\n  if (typeof contentField === \"function\") {\n    const result = contentField(arg);\n    return result;\n  }\n};\nconst signaturePrefix = \"hmac-sha256=\";\nconst algorithm = {\n  name: \"HMAC\",\n  hash: \"SHA-256\"\n};\nconst signPayload = async (payload, secret) => {\n  const encoder = new TextEncoder();\n  const signingKey = await crypto.subtle.importKey(\"raw\", encoder.encode(secret), algorithm, false, [\"sign\"]);\n  const signature = await crypto.subtle.sign(algorithm, signingKey, encoder.encode(payload)).then(sig => Buffer.from(sig).toString(\"hex\"));\n  return `${signaturePrefix}${signature}`;\n};\nconst verifySignature = async (payload, signature, secret) => {\n  const sig = signature?.slice(signaturePrefix.length);\n  if (!sig) return false;\n  const encoder = new TextEncoder();\n  const signingKey = await crypto.subtle.importKey(\"raw\", encoder.encode(secret), algorithm, false, [\"verify\"]);\n  return await crypto.subtle.verify(algorithm, signingKey, Uint8Array.from(Buffer.from(sig, \"hex\")), encoder.encode(payload));\n};\nexport { ALLOWED_FILE_TYPES, FILESIZE_UNITS, INTERNAL_DO_NOT_USE__fatalClientError, INTERNAL_doFormatting, UploadThingError, allowedContentTextLabelGenerator, asArray, capitalizeStart, contentDisposition, contentFieldToContent, fileSizeToBytes, fillInputRouteConfig, generateClientDropzoneAccept, generateMimeTypes, generatePermittedFileTypes, generateUploadThingURL, getDefaultSizeForType, getStatusCodeFromError, getTypeFromFileName, isObject, isRouteArray, objectKeys, pollForFileData, resolveMaybeUrlArg, safeParseJSON, semverLite, signPayload, styleFieldToClassName, styleFieldToCssObject, verifySignature, withExponentialBackoff };","map":{"version":3,"names":["process","lookup","isRouteArray","routeConfig","Array","isArray","getDefaultSizeForType","fileType","fillInputRouteConfig","reduce","acc","maxFileSize","maxFileCount","minFileCount","contentDisposition","newConfig","inputKeys","objectKeys","forEach","key","value","Error","defaultValues","getTypeFromFileName","fileName","allowedTypes","mimeType","includes","some","type","toLowerCase","split","generateUploadThingURL","path","host","env","CUSTOM_INFRA_URL","withExponentialBackoff","doTheThing","MAXIMUM_BACKOFF_MS","MAX_RETRIES","tries","backoffMs","backoffFuzzMs","result","undefined","Math","min","floor","random","console","error","Promise","r","setTimeout","pollForFileData","opts","callback","res","fetch","url","headers","apiKey","sdkVersion","maybeJson","safeParseJSON","message","status","Symbol","FILESIZE_UNITS","fileSizeToBytes","input","regex","RegExp","join","match","sizeValue","parseFloat","sizeUnit","toUpperCase","bytes","pow","indexOf","JSON","parse","err","text","obj","Object","keys","isObject","asArray","val","encodeURI","semverLite","required","toCheck","semverRegex","requiredMatch","toCheckMatch","_1","rMajor","rMinor","rPatch","_2","cMajor","cMinor","cPatch","startsWith","getFullApiUrl","maybeUrl","base","window","location","origin","VERCEL_URL","URL","pathname","resolveMaybeUrlArg","ALLOWED_FILE_TYPES","ERROR_CODES","BAD_REQUEST","NOT_FOUND","FORBIDDEN","INTERNAL_SERVER_ERROR","INTERNAL_CLIENT_ERROR","TOO_LARGE","TOO_SMALL","TOO_MANY_FILES","KEY_TOO_LONG","URL_GENERATION_FAILED","UPLOAD_FAILED","MISSING_ENV","FILE_LIMIT_EXCEEDED","messageFromUnknown","cause","fallback","UploadThingError","constructor","initOpts","code","data","Response","statusText","fromResponse","response","jsonOrError","getErrorTypeFromStatusCode","toObject","serialize","stringify","getStatusCodeFromError","statusCode","entries","INTERNAL_DO_NOT_USE__fatalClientError","e","generateMimeTypes","fileTypes","accepted","map","generateClientDropzoneAccept","mimeTypes","fromEntries","generatePermittedFileTypes","config","values","v","multiple","capitalizeStart","str","charAt","slice","INTERNAL_doFormatting","formattedTypes","f","length","lastType","pop","formattedKey","allowedContentTextLabelGenerator","styleFieldToClassName","styleField","args","styleFieldToCssObject","contentFieldToContent","contentField","arg","signaturePrefix","algorithm","name","hash","signPayload","payload","secret","encoder","TextEncoder","signingKey","crypto","subtle","importKey","encode","signature","sign","then","sig","Buffer","from","toString","verifySignature","verify","Uint8Array"],"sources":["D:/an3_facultate/sem1/IS/laboratoare/SocialApp-Fe/social-media-front/node_modules/@uploadthing/shared/dist/index.js"],"sourcesContent":["import { process } from 'std-env';\nimport { lookup } from '@uploadthing/mime-types';\n\nfunction isRouteArray(routeConfig) {\n    return Array.isArray(routeConfig);\n}\nfunction getDefaultSizeForType(fileType) {\n    if (fileType === \"image\") return \"4MB\";\n    if (fileType === \"video\") return \"16MB\";\n    if (fileType === \"audio\") return \"8MB\";\n    if (fileType === \"blob\") return \"8MB\";\n    if (fileType === \"pdf\") return \"4MB\";\n    if (fileType === \"text\") return \"64KB\";\n    return \"4MB\";\n}\n/**\n * This function takes in the user's input and \"upscales\" it to a full config\n *\n * Example:\n * ```ts\n * [\"image\"] => { image: { maxFileSize: \"4MB\", limit: 1 } }\n * ```\n */ function fillInputRouteConfig(routeConfig) {\n    // If array, apply defaults\n    if (isRouteArray(routeConfig)) {\n        return routeConfig.reduce((acc, fileType)=>{\n            acc[fileType] = {\n                // Apply defaults\n                maxFileSize: getDefaultSizeForType(fileType),\n                maxFileCount: 1,\n                minFileCount: 1,\n                contentDisposition: \"inline\"\n            };\n            return acc;\n        }, {});\n    }\n    // Backfill defaults onto config\n    const newConfig = {};\n    const inputKeys = objectKeys(routeConfig);\n    inputKeys.forEach((key)=>{\n        const value = routeConfig[key];\n        if (!value) throw new Error(\"Invalid config during fill\");\n        const defaultValues = {\n            maxFileSize: getDefaultSizeForType(key),\n            maxFileCount: 1,\n            minFileCount: 1,\n            contentDisposition: \"inline\"\n        };\n        newConfig[key] = {\n            ...defaultValues,\n            ...value\n        };\n    }, {});\n    return newConfig;\n}\nfunction getTypeFromFileName(fileName, allowedTypes) {\n    const mimeType = lookup(fileName);\n    if (!mimeType) {\n        if (allowedTypes.includes(\"blob\")) return \"blob\";\n        throw new Error(`Could not determine type for ${fileName}, presigned URL generation failed`);\n    }\n    // If the user has specified a specific mime type, use that\n    if (allowedTypes.some((type)=>type.includes(\"/\"))) {\n        if (allowedTypes.includes(mimeType)) {\n            return mimeType;\n        }\n    }\n    // Otherwise, we have a \"magic\" type eg. \"image\" or \"video\"\n    const type = mimeType.toLowerCase() === \"application/pdf\" ? \"pdf\" : mimeType.split(\"/\")[0];\n    if (!allowedTypes.includes(type)) {\n        // Blob is a catch-all for any file type not explicitly supported\n        if (allowedTypes.includes(\"blob\")) {\n            return \"blob\";\n        } else {\n            throw new Error(`File type ${type} not allowed for ${fileName}`);\n        }\n    }\n    return type;\n}\nfunction generateUploadThingURL(path) {\n    let host = \"https://uploadthing.com\";\n    if (process.env.CUSTOM_INFRA_URL) {\n        host = process.env.CUSTOM_INFRA_URL;\n    }\n    return `${host}${path}`;\n}\n/**\n * RETURN UNDEFINED TO KEEP GOING\n * SO MAKE SURE YOUR FUNCTION RETURNS SOMETHING\n * OTHERWISE IT'S AN IMPLICIT UNDEFINED AND WILL CAUSE\n * AN INFINITE LOOP\n */ const withExponentialBackoff = async (doTheThing, MAXIMUM_BACKOFF_MS = 64 * 1000, MAX_RETRIES = 20)=>{\n    let tries = 0;\n    let backoffMs = 500;\n    let backoffFuzzMs = 0;\n    let result = undefined;\n    while(tries <= MAX_RETRIES){\n        result = await doTheThing();\n        if (result !== undefined) return result;\n        tries += 1;\n        backoffMs = Math.min(MAXIMUM_BACKOFF_MS, backoffMs * 2);\n        backoffFuzzMs = Math.floor(Math.random() * 500);\n        if (tries > 3) {\n            console.error(`[UT] Call unsuccessful after ${tries} tries. Retrying in ${Math.floor(backoffMs / 1000)} seconds...`);\n        }\n        await new Promise((r)=>setTimeout(r, backoffMs + backoffFuzzMs));\n    }\n    return null;\n};\nasync function pollForFileData(opts, callback) {\n    return withExponentialBackoff(async ()=>{\n        const res = await opts.fetch(opts.url, {\n            headers: {\n                ...opts.apiKey && {\n                    \"x-uploadthing-api-key\": opts.apiKey\n                },\n                \"x-uploadthing-version\": opts.sdkVersion\n            }\n        });\n        const maybeJson = await safeParseJSON(res);\n        if (maybeJson instanceof Error) {\n            console.error(`[UT] Error polling for file data for ${opts.url}: ${maybeJson.message}`);\n            return null;\n        }\n        if (maybeJson.status !== \"done\") return undefined;\n        await callback?.(maybeJson);\n        return Symbol(\"backoff done without response\");\n    });\n}\nconst FILESIZE_UNITS = [\n    \"B\",\n    \"KB\",\n    \"MB\",\n    \"GB\"\n];\nconst fileSizeToBytes = (input)=>{\n    const regex = new RegExp(`^(\\\\d+)(\\\\.\\\\d+)?\\\\s*(${FILESIZE_UNITS.join(\"|\")})$`, \"i\");\n    const match = input.match(regex);\n    if (!match) {\n        return new Error(\"Invalid file size format\");\n    }\n    const sizeValue = parseFloat(match[1]);\n    const sizeUnit = match[3].toUpperCase();\n    if (!FILESIZE_UNITS.includes(sizeUnit)) {\n        throw new Error(\"Invalid file size unit\");\n    }\n    const bytes = sizeValue * Math.pow(1024, FILESIZE_UNITS.indexOf(sizeUnit));\n    return Math.floor(bytes);\n};\nasync function safeParseJSON(input) {\n    if (typeof input === \"string\") {\n        try {\n            return JSON.parse(input);\n        } catch (err) {\n            console.error(`Error parsing JSON, got '${input}'`);\n            return new Error(`Error parsing JSON, got '${input}'`);\n        }\n    }\n    const text = await input.text();\n    try {\n        return JSON.parse(text ?? \"null\");\n    } catch (err) {\n        console.error(`Error parsing JSON, got '${text}'`);\n        return new Error(`Error parsing JSON, got '${text}'`);\n    }\n}\n/** typesafe Object.keys */ function objectKeys(obj) {\n    return Object.keys(obj);\n}\n/** checks if obj is a valid, non-null object */ function isObject(obj) {\n    return typeof obj === \"object\" && obj !== null && !Array.isArray(obj);\n}\nfunction asArray(val) {\n    return Array.isArray(val) ? val : [\n        val\n    ];\n}\n/** construct content-disposition header */ function contentDisposition(contentDisposition, fileName) {\n    return [\n        contentDisposition,\n        `filename=\"${encodeURI(fileName)}\"`,\n        `filename*=UTF-8''${encodeURI(fileName)}`\n    ].join(\"; \");\n}\nfunction semverLite(required, toCheck) {\n    // Pull out numbers from strings like `6.0.0`, `^6.4`, `~6.4.0`\n    const semverRegex = /(\\d+)\\.?(\\d+)?\\.?(\\d+)?/;\n    const requiredMatch = required.match(semverRegex);\n    if (!requiredMatch?.[0]) {\n        throw new Error(`Invalid semver requirement: ${required}`);\n    }\n    const toCheckMatch = toCheck.match(semverRegex);\n    if (!toCheckMatch?.[0]) {\n        throw new Error(`Invalid semver to check: ${toCheck}`);\n    }\n    const [_1, rMajor, rMinor, rPatch] = requiredMatch;\n    const [_2, cMajor, cMinor, cPatch] = toCheckMatch;\n    if (required.startsWith(\"^\")) {\n        // Major must be equal, minor must be greater or equal\n        if (rMajor !== cMajor) return false;\n        if (rMinor > cMinor) return false;\n        return true;\n    }\n    if (required.startsWith(\"~\")) {\n        // Major must be equal, minor must be equal\n        if (rMajor !== cMajor) return false;\n        if (rMinor !== cMinor) return false;\n        return true;\n    }\n    // Exact match\n    return rMajor === cMajor && rMinor === cMinor && rPatch === cPatch;\n}\nfunction getFullApiUrl(maybeUrl) {\n    const base = (()=>{\n        if (typeof window !== \"undefined\") return window.location.origin;\n        if (process.env?.VERCEL_URL) return `https://${process.env.VERCEL_URL}`;\n        return \"http://localhost:3000\";\n    })();\n    try {\n        const url = new URL(maybeUrl ?? \"/api/uploadthing\", base);\n        if (url.pathname === \"/\") {\n            url.pathname = \"/api/uploadthing\";\n        }\n        return url;\n    } catch (err) {\n        throw new Error(`Failed to parse '${maybeUrl}' as a URL. Make sure it's a valid URL or path`);\n    }\n}\n/*\n * Returns a full URL to the dev's uploadthing endpoint\n * Can take either an origin, or a pathname, or a full URL\n * and will return the \"closest\" url matching the default\n * `<VERCEL_URL || localhost>/api/uploadthing`\n */ function resolveMaybeUrlArg(maybeUrl) {\n    return maybeUrl instanceof URL ? maybeUrl : getFullApiUrl(maybeUrl);\n}\n\nconst ALLOWED_FILE_TYPES = [\n    \"image\",\n    \"video\",\n    \"audio\",\n    \"pdf\",\n    \"text\",\n    \"blob\"\n];\n\nconst ERROR_CODES = {\n    // Generic\n    BAD_REQUEST: 400,\n    NOT_FOUND: 404,\n    FORBIDDEN: 403,\n    INTERNAL_SERVER_ERROR: 500,\n    INTERNAL_CLIENT_ERROR: 500,\n    // S3 specific\n    TOO_LARGE: 413,\n    TOO_SMALL: 400,\n    TOO_MANY_FILES: 400,\n    KEY_TOO_LONG: 400,\n    // UploadThing specific\n    URL_GENERATION_FAILED: 500,\n    UPLOAD_FAILED: 500,\n    MISSING_ENV: 500,\n    FILE_LIMIT_EXCEEDED: 500\n};\nfunction messageFromUnknown(cause, fallback) {\n    if (typeof cause === \"string\") {\n        return cause;\n    }\n    if (cause instanceof Error) {\n        return cause.message;\n    }\n    if (cause && typeof cause === \"object\" && \"message\" in cause && typeof cause.message === \"string\") {\n        return cause.message;\n    }\n    return fallback ?? \"An unknown error occurred\";\n}\nclass UploadThingError extends Error {\n    constructor(initOpts){\n        const opts = typeof initOpts === \"string\" ? {\n            code: \"INTERNAL_SERVER_ERROR\",\n            message: initOpts\n        } : initOpts;\n        const message = opts.message ?? messageFromUnknown(opts.cause, opts.code);\n        super(message);\n        this.code = opts.code;\n        this.data = opts.data;\n        if (opts.cause instanceof Error) {\n            this.cause = opts.cause;\n        } else if (opts.cause instanceof Response) {\n            this.cause = new Error(`Response ${opts.cause.status} ${opts.cause.statusText}`);\n        } else if (typeof opts.cause === \"string\") {\n            this.cause = new Error(opts.cause);\n        } else {\n            this.cause = opts.cause;\n        }\n    }\n    static async fromResponse(response) {\n        const jsonOrError = await safeParseJSON(response);\n        if (jsonOrError instanceof Error) {\n            return new UploadThingError({\n                message: jsonOrError.message,\n                code: getErrorTypeFromStatusCode(response.status),\n                cause: response\n            });\n        }\n        let message = undefined;\n        if (isObject(jsonOrError)) {\n            if (typeof jsonOrError.message === \"string\") {\n                message = jsonOrError.message;\n            } else if (typeof jsonOrError.error === \"string\") {\n                message = jsonOrError.error;\n            }\n        }\n        return new UploadThingError({\n            message,\n            code: getErrorTypeFromStatusCode(response.status),\n            cause: response,\n            data: jsonOrError\n        });\n    }\n    static toObject(error) {\n        return {\n            code: error.code,\n            message: error.message,\n            data: error.data\n        };\n    }\n    static serialize(error) {\n        return JSON.stringify(UploadThingError.toObject(error));\n    }\n}\nfunction getStatusCodeFromError(error) {\n    return ERROR_CODES[error.code] ?? 500;\n}\nfunction getErrorTypeFromStatusCode(statusCode) {\n    for (const [code, status] of Object.entries(ERROR_CODES)){\n        if (status === statusCode) {\n            return code;\n        }\n    }\n    return \"INTERNAL_SERVER_ERROR\";\n}\nconst INTERNAL_DO_NOT_USE__fatalClientError = (e)=>new UploadThingError({\n        code: \"INTERNAL_CLIENT_ERROR\",\n        message: \"Something went wrong. Please report this to UploadThing.\",\n        cause: e\n    });\n\nconst generateMimeTypes = (fileTypes)=>{\n    const accepted = fileTypes.map((type)=>{\n        if (type === \"blob\") return \"blob\";\n        if (type === \"pdf\") return \"application/pdf\";\n        if (type.includes(\"/\")) return type;\n        else return `${type}/*`;\n    });\n    if (accepted.includes(\"blob\")) {\n        return undefined;\n    }\n    return accepted;\n};\nconst generateClientDropzoneAccept = (fileTypes)=>{\n    const mimeTypes = generateMimeTypes(fileTypes);\n    if (!mimeTypes) return undefined;\n    return Object.fromEntries(mimeTypes.map((type)=>[\n            type,\n            []\n        ]));\n};\n/**\n * Shared helpers for our premade components that's reusable by multiple frameworks\n */ const generatePermittedFileTypes = (config)=>{\n    const fileTypes = config ? objectKeys(config) : [];\n    const maxFileCount = config ? Object.values(config).map((v)=>v.maxFileCount) : [];\n    return {\n        fileTypes,\n        multiple: maxFileCount.some((v)=>v && v > 1)\n    };\n};\nconst capitalizeStart = (str)=>{\n    return str.charAt(0).toUpperCase() + str.slice(1);\n};\nconst INTERNAL_doFormatting = (config)=>{\n    if (!config) return \"\";\n    const allowedTypes = objectKeys(config);\n    const formattedTypes = allowedTypes.map((f)=>f === \"blob\" ? \"file\" : f);\n    // Format multi-type uploader label as \"Supports videos, images and files\";\n    if (formattedTypes.length > 1) {\n        const lastType = formattedTypes.pop();\n        return `${formattedTypes.join(\"s, \")} and ${lastType}s`;\n    }\n    // Single type uploader label\n    const key = allowedTypes[0];\n    const formattedKey = formattedTypes[0];\n    const { maxFileSize, maxFileCount, minFileCount } = config[key];\n    if (maxFileCount && maxFileCount > 1) {\n        if (minFileCount > 1) {\n            return `${minFileCount} - ${maxFileCount} ${formattedKey}s up to ${maxFileSize}`;\n        } else {\n            return `${formattedKey}s up to ${maxFileSize}, max ${maxFileCount}`;\n        }\n    } else {\n        return `${formattedKey} (${maxFileSize})`;\n    }\n};\nconst allowedContentTextLabelGenerator = (config)=>{\n    return capitalizeStart(INTERNAL_doFormatting(config));\n};\nconst styleFieldToClassName = (styleField, args)=>{\n    if (typeof styleField === \"string\") return styleField;\n    if (typeof styleField === \"function\") {\n        const result = styleField(args);\n        if (typeof result === \"string\") return result;\n    }\n    return \"\";\n};\nconst styleFieldToCssObject = (styleField, args)=>{\n    if (typeof styleField === \"object\") return styleField;\n    if (typeof styleField === \"function\") {\n        const result = styleField(args);\n        if (typeof result === \"object\") return result;\n    }\n    return {};\n};\nconst contentFieldToContent = (contentField, arg)=>{\n    if (!contentField) return null;\n    if (typeof contentField !== \"function\") return contentField;\n    if (typeof contentField === \"function\") {\n        const result = contentField(arg);\n        return result;\n    }\n};\n\nconst signaturePrefix = \"hmac-sha256=\";\nconst algorithm = {\n    name: \"HMAC\",\n    hash: \"SHA-256\"\n};\nconst signPayload = async (payload, secret)=>{\n    const encoder = new TextEncoder();\n    const signingKey = await crypto.subtle.importKey(\"raw\", encoder.encode(secret), algorithm, false, [\n        \"sign\"\n    ]);\n    const signature = await crypto.subtle.sign(algorithm, signingKey, encoder.encode(payload)).then((sig)=>Buffer.from(sig).toString(\"hex\"));\n    return `${signaturePrefix}${signature}`;\n};\nconst verifySignature = async (payload, signature, secret)=>{\n    const sig = signature?.slice(signaturePrefix.length);\n    if (!sig) return false;\n    const encoder = new TextEncoder();\n    const signingKey = await crypto.subtle.importKey(\"raw\", encoder.encode(secret), algorithm, false, [\n        \"verify\"\n    ]);\n    return await crypto.subtle.verify(algorithm, signingKey, Uint8Array.from(Buffer.from(sig, \"hex\")), encoder.encode(payload));\n};\n\nexport { ALLOWED_FILE_TYPES, FILESIZE_UNITS, INTERNAL_DO_NOT_USE__fatalClientError, INTERNAL_doFormatting, UploadThingError, allowedContentTextLabelGenerator, asArray, capitalizeStart, contentDisposition, contentFieldToContent, fileSizeToBytes, fillInputRouteConfig, generateClientDropzoneAccept, generateMimeTypes, generatePermittedFileTypes, generateUploadThingURL, getDefaultSizeForType, getStatusCodeFromError, getTypeFromFileName, isObject, isRouteArray, objectKeys, pollForFileData, resolveMaybeUrlArg, safeParseJSON, semverLite, signPayload, styleFieldToClassName, styleFieldToCssObject, verifySignature, withExponentialBackoff };\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,SAAS;AACjC,SAASC,MAAM,QAAQ,yBAAyB;AAEhD,SAASC,YAAYA,CAACC,WAAW,EAAE;EAC/B,OAAOC,KAAK,CAACC,OAAO,CAACF,WAAW,CAAC;AACrC;AACA,SAASG,qBAAqBA,CAACC,QAAQ,EAAE;EACrC,IAAIA,QAAQ,KAAK,OAAO,EAAE,OAAO,KAAK;EACtC,IAAIA,QAAQ,KAAK,OAAO,EAAE,OAAO,MAAM;EACvC,IAAIA,QAAQ,KAAK,OAAO,EAAE,OAAO,KAAK;EACtC,IAAIA,QAAQ,KAAK,MAAM,EAAE,OAAO,KAAK;EACrC,IAAIA,QAAQ,KAAK,KAAK,EAAE,OAAO,KAAK;EACpC,IAAIA,QAAQ,KAAK,MAAM,EAAE,OAAO,MAAM;EACtC,OAAO,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAI,SAASC,oBAAoBA,CAACL,WAAW,EAAE;EAC3C;EACA,IAAID,YAAY,CAACC,WAAW,CAAC,EAAE;IAC3B,OAAOA,WAAW,CAACM,MAAM,CAAC,CAACC,GAAG,EAAEH,QAAQ,KAAG;MACvCG,GAAG,CAACH,QAAQ,CAAC,GAAG;QACZ;QACAI,WAAW,EAAEL,qBAAqB,CAACC,QAAQ,CAAC;QAC5CK,YAAY,EAAE,CAAC;QACfC,YAAY,EAAE,CAAC;QACfC,kBAAkB,EAAE;MACxB,CAAC;MACD,OAAOJ,GAAG;IACd,CAAC,EAAE,CAAC,CAAC,CAAC;EACV;EACA;EACA,MAAMK,SAAS,GAAG,CAAC,CAAC;EACpB,MAAMC,SAAS,GAAGC,UAAU,CAACd,WAAW,CAAC;EACzCa,SAAS,CAACE,OAAO,CAAEC,GAAG,IAAG;IACrB,MAAMC,KAAK,GAAGjB,WAAW,CAACgB,GAAG,CAAC;IAC9B,IAAI,CAACC,KAAK,EAAE,MAAM,IAAIC,KAAK,CAAC,4BAA4B,CAAC;IACzD,MAAMC,aAAa,GAAG;MAClBX,WAAW,EAAEL,qBAAqB,CAACa,GAAG,CAAC;MACvCP,YAAY,EAAE,CAAC;MACfC,YAAY,EAAE,CAAC;MACfC,kBAAkB,EAAE;IACxB,CAAC;IACDC,SAAS,CAACI,GAAG,CAAC,GAAG;MACb,GAAGG,aAAa;MAChB,GAAGF;IACP,CAAC;EACL,CAAC,EAAE,CAAC,CAAC,CAAC;EACN,OAAOL,SAAS;AACpB;AACA,SAASQ,mBAAmBA,CAACC,QAAQ,EAAEC,YAAY,EAAE;EACjD,MAAMC,QAAQ,GAAGzB,MAAM,CAACuB,QAAQ,CAAC;EACjC,IAAI,CAACE,QAAQ,EAAE;IACX,IAAID,YAAY,CAACE,QAAQ,CAAC,MAAM,CAAC,EAAE,OAAO,MAAM;IAChD,MAAM,IAAIN,KAAK,CAAE,gCAA+BG,QAAS,mCAAkC,CAAC;EAChG;EACA;EACA,IAAIC,YAAY,CAACG,IAAI,CAAEC,IAAI,IAAGA,IAAI,CAACF,QAAQ,CAAC,GAAG,CAAC,CAAC,EAAE;IAC/C,IAAIF,YAAY,CAACE,QAAQ,CAACD,QAAQ,CAAC,EAAE;MACjC,OAAOA,QAAQ;IACnB;EACJ;EACA;EACA,MAAMG,IAAI,GAAGH,QAAQ,CAACI,WAAW,CAAC,CAAC,KAAK,iBAAiB,GAAG,KAAK,GAAGJ,QAAQ,CAACK,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EAC1F,IAAI,CAACN,YAAY,CAACE,QAAQ,CAACE,IAAI,CAAC,EAAE;IAC9B;IACA,IAAIJ,YAAY,CAACE,QAAQ,CAAC,MAAM,CAAC,EAAE;MAC/B,OAAO,MAAM;IACjB,CAAC,MAAM;MACH,MAAM,IAAIN,KAAK,CAAE,aAAYQ,IAAK,oBAAmBL,QAAS,EAAC,CAAC;IACpE;EACJ;EACA,OAAOK,IAAI;AACf;AACA,SAASG,sBAAsBA,CAACC,IAAI,EAAE;EAClC,IAAIC,IAAI,GAAG,yBAAyB;EACpC,IAAIlC,OAAO,CAACmC,GAAG,CAACC,gBAAgB,EAAE;IAC9BF,IAAI,GAAGlC,OAAO,CAACmC,GAAG,CAACC,gBAAgB;EACvC;EACA,OAAQ,GAAEF,IAAK,GAAED,IAAK,EAAC;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AAAI,MAAMI,sBAAsB,GAAG,MAAAA,CAAOC,UAAU,EAAEC,kBAAkB,GAAG,EAAE,GAAG,IAAI,EAAEC,WAAW,GAAG,EAAE,KAAG;EACrG,IAAIC,KAAK,GAAG,CAAC;EACb,IAAIC,SAAS,GAAG,GAAG;EACnB,IAAIC,aAAa,GAAG,CAAC;EACrB,IAAIC,MAAM,GAAGC,SAAS;EACtB,OAAMJ,KAAK,IAAID,WAAW,EAAC;IACvBI,MAAM,GAAG,MAAMN,UAAU,CAAC,CAAC;IAC3B,IAAIM,MAAM,KAAKC,SAAS,EAAE,OAAOD,MAAM;IACvCH,KAAK,IAAI,CAAC;IACVC,SAAS,GAAGI,IAAI,CAACC,GAAG,CAACR,kBAAkB,EAAEG,SAAS,GAAG,CAAC,CAAC;IACvDC,aAAa,GAAGG,IAAI,CAACE,KAAK,CAACF,IAAI,CAACG,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC;IAC/C,IAAIR,KAAK,GAAG,CAAC,EAAE;MACXS,OAAO,CAACC,KAAK,CAAE,gCAA+BV,KAAM,uBAAsBK,IAAI,CAACE,KAAK,CAACN,SAAS,GAAG,IAAI,CAAE,aAAY,CAAC;IACxH;IACA,MAAM,IAAIU,OAAO,CAAEC,CAAC,IAAGC,UAAU,CAACD,CAAC,EAAEX,SAAS,GAAGC,aAAa,CAAC,CAAC;EACpE;EACA,OAAO,IAAI;AACf,CAAC;AACD,eAAeY,eAAeA,CAACC,IAAI,EAAEC,QAAQ,EAAE;EAC3C,OAAOpB,sBAAsB,CAAC,YAAU;IACpC,MAAMqB,GAAG,GAAG,MAAMF,IAAI,CAACG,KAAK,CAACH,IAAI,CAACI,GAAG,EAAE;MACnCC,OAAO,EAAE;QACL,IAAGL,IAAI,CAACM,MAAM,IAAI;UACd,uBAAuB,EAAEN,IAAI,CAACM;QAClC,CAAC;QACD,uBAAuB,EAAEN,IAAI,CAACO;MAClC;IACJ,CAAC,CAAC;IACF,MAAMC,SAAS,GAAG,MAAMC,aAAa,CAACP,GAAG,CAAC;IAC1C,IAAIM,SAAS,YAAY3C,KAAK,EAAE;MAC5B6B,OAAO,CAACC,KAAK,CAAE,wCAAuCK,IAAI,CAACI,GAAI,KAAII,SAAS,CAACE,OAAQ,EAAC,CAAC;MACvF,OAAO,IAAI;IACf;IACA,IAAIF,SAAS,CAACG,MAAM,KAAK,MAAM,EAAE,OAAOtB,SAAS;IACjD,MAAMY,QAAQ,GAAGO,SAAS,CAAC;IAC3B,OAAOI,MAAM,CAAC,+BAA+B,CAAC;EAClD,CAAC,CAAC;AACN;AACA,MAAMC,cAAc,GAAG,CACnB,GAAG,EACH,IAAI,EACJ,IAAI,EACJ,IAAI,CACP;AACD,MAAMC,eAAe,GAAIC,KAAK,IAAG;EAC7B,MAAMC,KAAK,GAAG,IAAIC,MAAM,CAAE,yBAAwBJ,cAAc,CAACK,IAAI,CAAC,GAAG,CAAE,IAAG,EAAE,GAAG,CAAC;EACpF,MAAMC,KAAK,GAAGJ,KAAK,CAACI,KAAK,CAACH,KAAK,CAAC;EAChC,IAAI,CAACG,KAAK,EAAE;IACR,OAAO,IAAItD,KAAK,CAAC,0BAA0B,CAAC;EAChD;EACA,MAAMuD,SAAS,GAAGC,UAAU,CAACF,KAAK,CAAC,CAAC,CAAC,CAAC;EACtC,MAAMG,QAAQ,GAAGH,KAAK,CAAC,CAAC,CAAC,CAACI,WAAW,CAAC,CAAC;EACvC,IAAI,CAACV,cAAc,CAAC1C,QAAQ,CAACmD,QAAQ,CAAC,EAAE;IACpC,MAAM,IAAIzD,KAAK,CAAC,wBAAwB,CAAC;EAC7C;EACA,MAAM2D,KAAK,GAAGJ,SAAS,GAAG9B,IAAI,CAACmC,GAAG,CAAC,IAAI,EAAEZ,cAAc,CAACa,OAAO,CAACJ,QAAQ,CAAC,CAAC;EAC1E,OAAOhC,IAAI,CAACE,KAAK,CAACgC,KAAK,CAAC;AAC5B,CAAC;AACD,eAAef,aAAaA,CAACM,KAAK,EAAE;EAChC,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC3B,IAAI;MACA,OAAOY,IAAI,CAACC,KAAK,CAACb,KAAK,CAAC;IAC5B,CAAC,CAAC,OAAOc,GAAG,EAAE;MACVnC,OAAO,CAACC,KAAK,CAAE,4BAA2BoB,KAAM,GAAE,CAAC;MACnD,OAAO,IAAIlD,KAAK,CAAE,4BAA2BkD,KAAM,GAAE,CAAC;IAC1D;EACJ;EACA,MAAMe,IAAI,GAAG,MAAMf,KAAK,CAACe,IAAI,CAAC,CAAC;EAC/B,IAAI;IACA,OAAOH,IAAI,CAACC,KAAK,CAACE,IAAI,IAAI,MAAM,CAAC;EACrC,CAAC,CAAC,OAAOD,GAAG,EAAE;IACVnC,OAAO,CAACC,KAAK,CAAE,4BAA2BmC,IAAK,GAAE,CAAC;IAClD,OAAO,IAAIjE,KAAK,CAAE,4BAA2BiE,IAAK,GAAE,CAAC;EACzD;AACJ;AACA;AAA4B,SAASrE,UAAUA,CAACsE,GAAG,EAAE;EACjD,OAAOC,MAAM,CAACC,IAAI,CAACF,GAAG,CAAC;AAC3B;AACA;AAAiD,SAASG,QAAQA,CAACH,GAAG,EAAE;EACpE,OAAO,OAAOA,GAAG,KAAK,QAAQ,IAAIA,GAAG,KAAK,IAAI,IAAI,CAACnF,KAAK,CAACC,OAAO,CAACkF,GAAG,CAAC;AACzE;AACA,SAASI,OAAOA,CAACC,GAAG,EAAE;EAClB,OAAOxF,KAAK,CAACC,OAAO,CAACuF,GAAG,CAAC,GAAGA,GAAG,GAAG,CAC9BA,GAAG,CACN;AACL;AACA;AAA4C,SAAS9E,kBAAkBA,CAACA,kBAAkB,EAAEU,QAAQ,EAAE;EAClG,OAAO,CACHV,kBAAkB,EACjB,aAAY+E,SAAS,CAACrE,QAAQ,CAAE,GAAE,EAClC,oBAAmBqE,SAAS,CAACrE,QAAQ,CAAE,EAAC,CAC5C,CAACkD,IAAI,CAAC,IAAI,CAAC;AAChB;AACA,SAASoB,UAAUA,CAACC,QAAQ,EAAEC,OAAO,EAAE;EACnC;EACA,MAAMC,WAAW,GAAG,yBAAyB;EAC7C,MAAMC,aAAa,GAAGH,QAAQ,CAACpB,KAAK,CAACsB,WAAW,CAAC;EACjD,IAAI,CAACC,aAAa,GAAG,CAAC,CAAC,EAAE;IACrB,MAAM,IAAI7E,KAAK,CAAE,+BAA8B0E,QAAS,EAAC,CAAC;EAC9D;EACA,MAAMI,YAAY,GAAGH,OAAO,CAACrB,KAAK,CAACsB,WAAW,CAAC;EAC/C,IAAI,CAACE,YAAY,GAAG,CAAC,CAAC,EAAE;IACpB,MAAM,IAAI9E,KAAK,CAAE,4BAA2B2E,OAAQ,EAAC,CAAC;EAC1D;EACA,MAAM,CAACI,EAAE,EAAEC,MAAM,EAAEC,MAAM,EAAEC,MAAM,CAAC,GAAGL,aAAa;EAClD,MAAM,CAACM,EAAE,EAAEC,MAAM,EAAEC,MAAM,EAAEC,MAAM,CAAC,GAAGR,YAAY;EACjD,IAAIJ,QAAQ,CAACa,UAAU,CAAC,GAAG,CAAC,EAAE;IAC1B;IACA,IAAIP,MAAM,KAAKI,MAAM,EAAE,OAAO,KAAK;IACnC,IAAIH,MAAM,GAAGI,MAAM,EAAE,OAAO,KAAK;IACjC,OAAO,IAAI;EACf;EACA,IAAIX,QAAQ,CAACa,UAAU,CAAC,GAAG,CAAC,EAAE;IAC1B;IACA,IAAIP,MAAM,KAAKI,MAAM,EAAE,OAAO,KAAK;IACnC,IAAIH,MAAM,KAAKI,MAAM,EAAE,OAAO,KAAK;IACnC,OAAO,IAAI;EACf;EACA;EACA,OAAOL,MAAM,KAAKI,MAAM,IAAIH,MAAM,KAAKI,MAAM,IAAIH,MAAM,KAAKI,MAAM;AACtE;AACA,SAASE,aAAaA,CAACC,QAAQ,EAAE;EAC7B,MAAMC,IAAI,GAAG,CAAC,MAAI;IACd,IAAI,OAAOC,MAAM,KAAK,WAAW,EAAE,OAAOA,MAAM,CAACC,QAAQ,CAACC,MAAM;IAChE,IAAIlH,OAAO,CAACmC,GAAG,EAAEgF,UAAU,EAAE,OAAQ,WAAUnH,OAAO,CAACmC,GAAG,CAACgF,UAAW,EAAC;IACvE,OAAO,uBAAuB;EAClC,CAAC,EAAE,CAAC;EACJ,IAAI;IACA,MAAMvD,GAAG,GAAG,IAAIwD,GAAG,CAACN,QAAQ,IAAI,kBAAkB,EAAEC,IAAI,CAAC;IACzD,IAAInD,GAAG,CAACyD,QAAQ,KAAK,GAAG,EAAE;MACtBzD,GAAG,CAACyD,QAAQ,GAAG,kBAAkB;IACrC;IACA,OAAOzD,GAAG;EACd,CAAC,CAAC,OAAOyB,GAAG,EAAE;IACV,MAAM,IAAIhE,KAAK,CAAE,oBAAmByF,QAAS,gDAA+C,CAAC;EACjG;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AAAI,SAASQ,kBAAkBA,CAACR,QAAQ,EAAE;EACtC,OAAOA,QAAQ,YAAYM,GAAG,GAAGN,QAAQ,GAAGD,aAAa,CAACC,QAAQ,CAAC;AACvE;AAEA,MAAMS,kBAAkB,GAAG,CACvB,OAAO,EACP,OAAO,EACP,OAAO,EACP,KAAK,EACL,MAAM,EACN,MAAM,CACT;AAED,MAAMC,WAAW,GAAG;EAChB;EACAC,WAAW,EAAE,GAAG;EAChBC,SAAS,EAAE,GAAG;EACdC,SAAS,EAAE,GAAG;EACdC,qBAAqB,EAAE,GAAG;EAC1BC,qBAAqB,EAAE,GAAG;EAC1B;EACAC,SAAS,EAAE,GAAG;EACdC,SAAS,EAAE,GAAG;EACdC,cAAc,EAAE,GAAG;EACnBC,YAAY,EAAE,GAAG;EACjB;EACAC,qBAAqB,EAAE,GAAG;EAC1BC,aAAa,EAAE,GAAG;EAClBC,WAAW,EAAE,GAAG;EAChBC,mBAAmB,EAAE;AACzB,CAAC;AACD,SAASC,kBAAkBA,CAACC,KAAK,EAAEC,QAAQ,EAAE;EACzC,IAAI,OAAOD,KAAK,KAAK,QAAQ,EAAE;IAC3B,OAAOA,KAAK;EAChB;EACA,IAAIA,KAAK,YAAYlH,KAAK,EAAE;IACxB,OAAOkH,KAAK,CAACrE,OAAO;EACxB;EACA,IAAIqE,KAAK,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI,SAAS,IAAIA,KAAK,IAAI,OAAOA,KAAK,CAACrE,OAAO,KAAK,QAAQ,EAAE;IAC/F,OAAOqE,KAAK,CAACrE,OAAO;EACxB;EACA,OAAOsE,QAAQ,IAAI,2BAA2B;AAClD;AACA,MAAMC,gBAAgB,SAASpH,KAAK,CAAC;EACjCqH,WAAWA,CAACC,QAAQ,EAAC;IACjB,MAAMnF,IAAI,GAAG,OAAOmF,QAAQ,KAAK,QAAQ,GAAG;MACxCC,IAAI,EAAE,uBAAuB;MAC7B1E,OAAO,EAAEyE;IACb,CAAC,GAAGA,QAAQ;IACZ,MAAMzE,OAAO,GAAGV,IAAI,CAACU,OAAO,IAAIoE,kBAAkB,CAAC9E,IAAI,CAAC+E,KAAK,EAAE/E,IAAI,CAACoF,IAAI,CAAC;IACzE,KAAK,CAAC1E,OAAO,CAAC;IACd,IAAI,CAAC0E,IAAI,GAAGpF,IAAI,CAACoF,IAAI;IACrB,IAAI,CAACC,IAAI,GAAGrF,IAAI,CAACqF,IAAI;IACrB,IAAIrF,IAAI,CAAC+E,KAAK,YAAYlH,KAAK,EAAE;MAC7B,IAAI,CAACkH,KAAK,GAAG/E,IAAI,CAAC+E,KAAK;IAC3B,CAAC,MAAM,IAAI/E,IAAI,CAAC+E,KAAK,YAAYO,QAAQ,EAAE;MACvC,IAAI,CAACP,KAAK,GAAG,IAAIlH,KAAK,CAAE,YAAWmC,IAAI,CAAC+E,KAAK,CAACpE,MAAO,IAAGX,IAAI,CAAC+E,KAAK,CAACQ,UAAW,EAAC,CAAC;IACpF,CAAC,MAAM,IAAI,OAAOvF,IAAI,CAAC+E,KAAK,KAAK,QAAQ,EAAE;MACvC,IAAI,CAACA,KAAK,GAAG,IAAIlH,KAAK,CAACmC,IAAI,CAAC+E,KAAK,CAAC;IACtC,CAAC,MAAM;MACH,IAAI,CAACA,KAAK,GAAG/E,IAAI,CAAC+E,KAAK;IAC3B;EACJ;EACA,aAAaS,YAAYA,CAACC,QAAQ,EAAE;IAChC,MAAMC,WAAW,GAAG,MAAMjF,aAAa,CAACgF,QAAQ,CAAC;IACjD,IAAIC,WAAW,YAAY7H,KAAK,EAAE;MAC9B,OAAO,IAAIoH,gBAAgB,CAAC;QACxBvE,OAAO,EAAEgF,WAAW,CAAChF,OAAO;QAC5B0E,IAAI,EAAEO,0BAA0B,CAACF,QAAQ,CAAC9E,MAAM,CAAC;QACjDoE,KAAK,EAAEU;MACX,CAAC,CAAC;IACN;IACA,IAAI/E,OAAO,GAAGrB,SAAS;IACvB,IAAI6C,QAAQ,CAACwD,WAAW,CAAC,EAAE;MACvB,IAAI,OAAOA,WAAW,CAAChF,OAAO,KAAK,QAAQ,EAAE;QACzCA,OAAO,GAAGgF,WAAW,CAAChF,OAAO;MACjC,CAAC,MAAM,IAAI,OAAOgF,WAAW,CAAC/F,KAAK,KAAK,QAAQ,EAAE;QAC9Ce,OAAO,GAAGgF,WAAW,CAAC/F,KAAK;MAC/B;IACJ;IACA,OAAO,IAAIsF,gBAAgB,CAAC;MACxBvE,OAAO;MACP0E,IAAI,EAAEO,0BAA0B,CAACF,QAAQ,CAAC9E,MAAM,CAAC;MACjDoE,KAAK,EAAEU,QAAQ;MACfJ,IAAI,EAAEK;IACV,CAAC,CAAC;EACN;EACA,OAAOE,QAAQA,CAACjG,KAAK,EAAE;IACnB,OAAO;MACHyF,IAAI,EAAEzF,KAAK,CAACyF,IAAI;MAChB1E,OAAO,EAAEf,KAAK,CAACe,OAAO;MACtB2E,IAAI,EAAE1F,KAAK,CAAC0F;IAChB,CAAC;EACL;EACA,OAAOQ,SAASA,CAAClG,KAAK,EAAE;IACpB,OAAOgC,IAAI,CAACmE,SAAS,CAACb,gBAAgB,CAACW,QAAQ,CAACjG,KAAK,CAAC,CAAC;EAC3D;AACJ;AACA,SAASoG,sBAAsBA,CAACpG,KAAK,EAAE;EACnC,OAAOqE,WAAW,CAACrE,KAAK,CAACyF,IAAI,CAAC,IAAI,GAAG;AACzC;AACA,SAASO,0BAA0BA,CAACK,UAAU,EAAE;EAC5C,KAAK,MAAM,CAACZ,IAAI,EAAEzE,MAAM,CAAC,IAAIqB,MAAM,CAACiE,OAAO,CAACjC,WAAW,CAAC,EAAC;IACrD,IAAIrD,MAAM,KAAKqF,UAAU,EAAE;MACvB,OAAOZ,IAAI;IACf;EACJ;EACA,OAAO,uBAAuB;AAClC;AACA,MAAMc,qCAAqC,GAAIC,CAAC,IAAG,IAAIlB,gBAAgB,CAAC;EAChEG,IAAI,EAAE,uBAAuB;EAC7B1E,OAAO,EAAE,0DAA0D;EACnEqE,KAAK,EAAEoB;AACX,CAAC,CAAC;AAEN,MAAMC,iBAAiB,GAAIC,SAAS,IAAG;EACnC,MAAMC,QAAQ,GAAGD,SAAS,CAACE,GAAG,CAAElI,IAAI,IAAG;IACnC,IAAIA,IAAI,KAAK,MAAM,EAAE,OAAO,MAAM;IAClC,IAAIA,IAAI,KAAK,KAAK,EAAE,OAAO,iBAAiB;IAC5C,IAAIA,IAAI,CAACF,QAAQ,CAAC,GAAG,CAAC,EAAE,OAAOE,IAAI,CAAC,KAC/B,OAAQ,GAAEA,IAAK,IAAG;EAC3B,CAAC,CAAC;EACF,IAAIiI,QAAQ,CAACnI,QAAQ,CAAC,MAAM,CAAC,EAAE;IAC3B,OAAOkB,SAAS;EACpB;EACA,OAAOiH,QAAQ;AACnB,CAAC;AACD,MAAME,4BAA4B,GAAIH,SAAS,IAAG;EAC9C,MAAMI,SAAS,GAAGL,iBAAiB,CAACC,SAAS,CAAC;EAC9C,IAAI,CAACI,SAAS,EAAE,OAAOpH,SAAS;EAChC,OAAO2C,MAAM,CAAC0E,WAAW,CAACD,SAAS,CAACF,GAAG,CAAElI,IAAI,IAAG,CACxCA,IAAI,EACJ,EAAE,CACL,CAAC,CAAC;AACX,CAAC;AACD;AACA;AACA;AAAI,MAAMsI,0BAA0B,GAAIC,MAAM,IAAG;EAC7C,MAAMP,SAAS,GAAGO,MAAM,GAAGnJ,UAAU,CAACmJ,MAAM,CAAC,GAAG,EAAE;EAClD,MAAMxJ,YAAY,GAAGwJ,MAAM,GAAG5E,MAAM,CAAC6E,MAAM,CAACD,MAAM,CAAC,CAACL,GAAG,CAAEO,CAAC,IAAGA,CAAC,CAAC1J,YAAY,CAAC,GAAG,EAAE;EACjF,OAAO;IACHiJ,SAAS;IACTU,QAAQ,EAAE3J,YAAY,CAACgB,IAAI,CAAE0I,CAAC,IAAGA,CAAC,IAAIA,CAAC,GAAG,CAAC;EAC/C,CAAC;AACL,CAAC;AACD,MAAME,eAAe,GAAIC,GAAG,IAAG;EAC3B,OAAOA,GAAG,CAACC,MAAM,CAAC,CAAC,CAAC,CAAC3F,WAAW,CAAC,CAAC,GAAG0F,GAAG,CAACE,KAAK,CAAC,CAAC,CAAC;AACrD,CAAC;AACD,MAAMC,qBAAqB,GAAIR,MAAM,IAAG;EACpC,IAAI,CAACA,MAAM,EAAE,OAAO,EAAE;EACtB,MAAM3I,YAAY,GAAGR,UAAU,CAACmJ,MAAM,CAAC;EACvC,MAAMS,cAAc,GAAGpJ,YAAY,CAACsI,GAAG,CAAEe,CAAC,IAAGA,CAAC,KAAK,MAAM,GAAG,MAAM,GAAGA,CAAC,CAAC;EACvE;EACA,IAAID,cAAc,CAACE,MAAM,GAAG,CAAC,EAAE;IAC3B,MAAMC,QAAQ,GAAGH,cAAc,CAACI,GAAG,CAAC,CAAC;IACrC,OAAQ,GAAEJ,cAAc,CAACnG,IAAI,CAAC,KAAK,CAAE,QAAOsG,QAAS,GAAE;EAC3D;EACA;EACA,MAAM7J,GAAG,GAAGM,YAAY,CAAC,CAAC,CAAC;EAC3B,MAAMyJ,YAAY,GAAGL,cAAc,CAAC,CAAC,CAAC;EACtC,MAAM;IAAElK,WAAW;IAAEC,YAAY;IAAEC;EAAa,CAAC,GAAGuJ,MAAM,CAACjJ,GAAG,CAAC;EAC/D,IAAIP,YAAY,IAAIA,YAAY,GAAG,CAAC,EAAE;IAClC,IAAIC,YAAY,GAAG,CAAC,EAAE;MAClB,OAAQ,GAAEA,YAAa,MAAKD,YAAa,IAAGsK,YAAa,WAAUvK,WAAY,EAAC;IACpF,CAAC,MAAM;MACH,OAAQ,GAAEuK,YAAa,WAAUvK,WAAY,SAAQC,YAAa,EAAC;IACvE;EACJ,CAAC,MAAM;IACH,OAAQ,GAAEsK,YAAa,KAAIvK,WAAY,GAAE;EAC7C;AACJ,CAAC;AACD,MAAMwK,gCAAgC,GAAIf,MAAM,IAAG;EAC/C,OAAOI,eAAe,CAACI,qBAAqB,CAACR,MAAM,CAAC,CAAC;AACzD,CAAC;AACD,MAAMgB,qBAAqB,GAAGA,CAACC,UAAU,EAAEC,IAAI,KAAG;EAC9C,IAAI,OAAOD,UAAU,KAAK,QAAQ,EAAE,OAAOA,UAAU;EACrD,IAAI,OAAOA,UAAU,KAAK,UAAU,EAAE;IAClC,MAAMzI,MAAM,GAAGyI,UAAU,CAACC,IAAI,CAAC;IAC/B,IAAI,OAAO1I,MAAM,KAAK,QAAQ,EAAE,OAAOA,MAAM;EACjD;EACA,OAAO,EAAE;AACb,CAAC;AACD,MAAM2I,qBAAqB,GAAGA,CAACF,UAAU,EAAEC,IAAI,KAAG;EAC9C,IAAI,OAAOD,UAAU,KAAK,QAAQ,EAAE,OAAOA,UAAU;EACrD,IAAI,OAAOA,UAAU,KAAK,UAAU,EAAE;IAClC,MAAMzI,MAAM,GAAGyI,UAAU,CAACC,IAAI,CAAC;IAC/B,IAAI,OAAO1I,MAAM,KAAK,QAAQ,EAAE,OAAOA,MAAM;EACjD;EACA,OAAO,CAAC,CAAC;AACb,CAAC;AACD,MAAM4I,qBAAqB,GAAGA,CAACC,YAAY,EAAEC,GAAG,KAAG;EAC/C,IAAI,CAACD,YAAY,EAAE,OAAO,IAAI;EAC9B,IAAI,OAAOA,YAAY,KAAK,UAAU,EAAE,OAAOA,YAAY;EAC3D,IAAI,OAAOA,YAAY,KAAK,UAAU,EAAE;IACpC,MAAM7I,MAAM,GAAG6I,YAAY,CAACC,GAAG,CAAC;IAChC,OAAO9I,MAAM;EACjB;AACJ,CAAC;AAED,MAAM+I,eAAe,GAAG,cAAc;AACtC,MAAMC,SAAS,GAAG;EACdC,IAAI,EAAE,MAAM;EACZC,IAAI,EAAE;AACV,CAAC;AACD,MAAMC,WAAW,GAAG,MAAAA,CAAOC,OAAO,EAAEC,MAAM,KAAG;EACzC,MAAMC,OAAO,GAAG,IAAIC,WAAW,CAAC,CAAC;EACjC,MAAMC,UAAU,GAAG,MAAMC,MAAM,CAACC,MAAM,CAACC,SAAS,CAAC,KAAK,EAAEL,OAAO,CAACM,MAAM,CAACP,MAAM,CAAC,EAAEL,SAAS,EAAE,KAAK,EAAE,CAC9F,MAAM,CACT,CAAC;EACF,MAAMa,SAAS,GAAG,MAAMJ,MAAM,CAACC,MAAM,CAACI,IAAI,CAACd,SAAS,EAAEQ,UAAU,EAAEF,OAAO,CAACM,MAAM,CAACR,OAAO,CAAC,CAAC,CAACW,IAAI,CAAEC,GAAG,IAAGC,MAAM,CAACC,IAAI,CAACF,GAAG,CAAC,CAACG,QAAQ,CAAC,KAAK,CAAC,CAAC;EACxI,OAAQ,GAAEpB,eAAgB,GAAEc,SAAU,EAAC;AAC3C,CAAC;AACD,MAAMO,eAAe,GAAG,MAAAA,CAAOhB,OAAO,EAAES,SAAS,EAAER,MAAM,KAAG;EACxD,MAAMW,GAAG,GAAGH,SAAS,EAAE9B,KAAK,CAACgB,eAAe,CAACZ,MAAM,CAAC;EACpD,IAAI,CAAC6B,GAAG,EAAE,OAAO,KAAK;EACtB,MAAMV,OAAO,GAAG,IAAIC,WAAW,CAAC,CAAC;EACjC,MAAMC,UAAU,GAAG,MAAMC,MAAM,CAACC,MAAM,CAACC,SAAS,CAAC,KAAK,EAAEL,OAAO,CAACM,MAAM,CAACP,MAAM,CAAC,EAAEL,SAAS,EAAE,KAAK,EAAE,CAC9F,QAAQ,CACX,CAAC;EACF,OAAO,MAAMS,MAAM,CAACC,MAAM,CAACW,MAAM,CAACrB,SAAS,EAAEQ,UAAU,EAAEc,UAAU,CAACJ,IAAI,CAACD,MAAM,CAACC,IAAI,CAACF,GAAG,EAAE,KAAK,CAAC,CAAC,EAAEV,OAAO,CAACM,MAAM,CAACR,OAAO,CAAC,CAAC;AAC/H,CAAC;AAED,SAASzE,kBAAkB,EAAElD,cAAc,EAAEqF,qCAAqC,EAAEkB,qBAAqB,EAAEnC,gBAAgB,EAAE0C,gCAAgC,EAAExF,OAAO,EAAE6E,eAAe,EAAE1J,kBAAkB,EAAE0K,qBAAqB,EAAElH,eAAe,EAAE9D,oBAAoB,EAAEwJ,4BAA4B,EAAEJ,iBAAiB,EAAEO,0BAA0B,EAAEnI,sBAAsB,EAAE1B,qBAAqB,EAAEiJ,sBAAsB,EAAEhI,mBAAmB,EAAEmE,QAAQ,EAAExF,YAAY,EAAEe,UAAU,EAAEsC,eAAe,EAAE+D,kBAAkB,EAAErD,aAAa,EAAE6B,UAAU,EAAEiG,WAAW,EAAEX,qBAAqB,EAAEG,qBAAqB,EAAEyB,eAAe,EAAE3K,sBAAsB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}