{"ast":null,"code":"import { contentDisposition, UploadThingError, safeParseJSON, resolveMaybeUrlArg, withExponentialBackoff } from '@uploadthing/shared';\nexport { generateClientDropzoneAccept, generateMimeTypes, generatePermittedFileTypes } from '@uploadthing/shared';\nvar version$1 = \"6.9.0\";\nconst maybeParseResponseXML = maybeXml => {\n  const codeMatch = maybeXml.match(/<Code>(.*?)<\\/Code>/s);\n  const messageMatch = maybeXml.match(/<Message>(.*?)<\\/Message>/s);\n  const code = codeMatch?.[1];\n  const message = messageMatch?.[1];\n  if (!code || !message) return null;\n  return {\n    code: s3CodeToUploadThingCode[code] ?? DEFAULT_ERROR_CODE,\n    message\n  };\n};\n/**\n * Map S3 error codes to UploadThing error codes\n *\n * This is a subset of the S3 error codes, based on what seemed most likely to\n * occur in uploadthing. For a full list of S3 error codes, see:\n * https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html\n */\nconst DEFAULT_ERROR_CODE = \"UPLOAD_FAILED\";\nconst s3CodeToUploadThingCode = {\n  AccessDenied: \"FORBIDDEN\",\n  EntityTooSmall: \"TOO_SMALL\",\n  EntityTooLarge: \"TOO_LARGE\",\n  ExpiredToken: \"FORBIDDEN\",\n  IncorrectNumberOfFilesInPostRequest: \"TOO_MANY_FILES\",\n  InternalError: \"INTERNAL_SERVER_ERROR\",\n  KeyTooLongError: \"KEY_TOO_LONG\",\n  MaxMessageLengthExceeded: \"TOO_LARGE\"\n};\n\n/**\n * Used by client uploads where progress is needed.\n * Uses XMLHttpRequest.\n */\nasync function uploadPartWithProgress(opts, retryCount = 0) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open(\"PUT\", opts.url, true);\n    xhr.setRequestHeader(\"Content-Type\", opts.fileType);\n    xhr.setRequestHeader(\"Content-Disposition\", contentDisposition(opts.contentDisposition, opts.fileName));\n    xhr.onload = async () => {\n      if (xhr.status >= 200 && xhr.status < 300) {\n        const etag = xhr.getResponseHeader(\"Etag\");\n        etag ? resolve(etag) : reject(\"NO ETAG\");\n      } else if (retryCount < opts.maxRetries) {\n        // Add a delay before retrying (exponential backoff can be used)\n        const delay = Math.pow(2, retryCount) * 1000;\n        await new Promise(res => setTimeout(res, delay));\n        resolve(await uploadPartWithProgress(opts, retryCount + 1)); // Retry the request\n      } else {\n        reject(\"Max retries exceeded\");\n      }\n    };\n    let lastProgress = 0;\n    xhr.onerror = async () => {\n      lastProgress = 0;\n      if (retryCount < opts.maxRetries) {\n        // Add a delay before retrying (exponential backoff can be used)\n        const delay = Math.pow(2, retryCount) * 100;\n        await new Promise(res => setTimeout(res, delay));\n        await uploadPartWithProgress(opts, retryCount + 1); // Retry the request\n      } else {\n        reject(\"Max retries exceeded\");\n      }\n    };\n    xhr.upload.onprogress = e => {\n      const delta = e.loaded - lastProgress;\n      lastProgress += delta;\n      opts.onProgress(delta);\n    };\n    xhr.send(opts.chunk);\n  });\n}\nconst createAPIRequestUrl = config => {\n  const url = new URL(config.url);\n  const queryParams = new URLSearchParams(url.search);\n  queryParams.set(\"actionType\", config.actionType);\n  queryParams.set(\"slug\", config.slug);\n  url.search = queryParams.toString();\n  return url;\n};\n/**\n * Creates a \"client\" for reporting events to the UploadThing server via the user's API endpoint.\n * Events are handled in \"./handler.ts starting at L200\"\n */\nconst createUTReporter = cfg => {\n  return async (type, payload) => {\n    const url = createAPIRequestUrl({\n      url: cfg.url,\n      slug: cfg.endpoint,\n      actionType: type\n    });\n    let customHeaders = typeof cfg.headers === \"function\" ? cfg.headers() : cfg.headers;\n    if (customHeaders instanceof Promise) customHeaders = await customHeaders;\n    const response = await cfg.fetch(url, {\n      method: \"POST\",\n      body: JSON.stringify(payload),\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"x-uploadthing-package\": cfg.package,\n        \"x-uploadthing-version\": version$1,\n        ...customHeaders\n      }\n    });\n    switch (type) {\n      case \"failure\":\n        {\n          // why isn't this narrowed automatically?\n          const p = payload;\n          const parsed = maybeParseResponseXML(p.s3Error ?? \"\");\n          if (parsed?.message) {\n            throw new UploadThingError({\n              code: parsed.code,\n              message: parsed.message\n            });\n          } else {\n            throw new UploadThingError({\n              code: \"UPLOAD_FAILED\",\n              message: `Failed to upload file ${p.fileName} to S3`,\n              cause: p.s3Error\n            });\n          }\n        }\n    }\n    if (!response.ok) {\n      const error = await UploadThingError.fromResponse(response);\n      throw error;\n    }\n    const jsonOrError = await safeParseJSON(response);\n    if (jsonOrError instanceof Error) {\n      throw new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: jsonOrError.message,\n        cause: response\n      });\n    }\n    return jsonOrError;\n  };\n};\n\n// Don't want to ship our logger to the client, keep size down\nconst version = version$1;\nconst uploadFilesInternal = async (endpoint, opts) => {\n  // Fine to use global fetch in browser\n  const fetch = globalThis.fetch.bind(globalThis);\n  const reportEventToUT = createUTReporter({\n    endpoint: String(endpoint),\n    url: opts.url,\n    package: opts.package,\n    fetch,\n    headers: opts.headers\n  });\n  // Get presigned URL for S3 upload\n  const s3ConnectionRes = await reportEventToUT(\"upload\", {\n    input: \"input\" in opts ? opts.input : null,\n    files: opts.files.map(f => ({\n      name: f.name,\n      size: f.size,\n      type: f.type\n    }))\n  });\n  if (!s3ConnectionRes || !Array.isArray(s3ConnectionRes)) {\n    throw new UploadThingError({\n      code: \"BAD_REQUEST\",\n      message: \"No URL. How did you even get here?\",\n      cause: s3ConnectionRes\n    });\n  }\n  const fileUploadPromises = s3ConnectionRes.map(async presigned => {\n    const file = opts.files.find(f => f.name === presigned.fileName);\n    if (!file) {\n      console.error(\"No file found for presigned URL\", presigned);\n      throw new UploadThingError({\n        code: \"NOT_FOUND\",\n        message: \"No file found for presigned URL\",\n        cause: `Expected file with name ${presigned.fileName} but got '${opts.files.join(\",\")}'`\n      });\n    }\n    opts.onUploadBegin?.({\n      file: file.name\n    });\n    if (\"urls\" in presigned) {\n      await uploadMultipart(file, presigned, {\n        reportEventToUT,\n        ...opts\n      });\n      // wait a bit as it's unsreasonable to expect the server to be done by now\n      await new Promise(r => setTimeout(r, 750));\n    } else {\n      await uploadPresignedPost(file, presigned, {\n        reportEventToUT,\n        ...opts\n      });\n    }\n    let serverData = null;\n    if (!opts.skipPolling) {\n      serverData = await withExponentialBackoff(async () => {\n        const res = await fetch(presigned.pollingUrl, {\n          headers: {\n            authorization: presigned.pollingJwt\n          }\n        }).then(r => r.json());\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return res.status === \"done\" ? res.callbackData : undefined;\n      });\n    }\n    return {\n      name: file.name,\n      size: file.size,\n      type: file.type,\n      key: presigned.key,\n      url: \"https://utfs.io/f/\" + presigned.key,\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      serverData: serverData,\n      customId: presigned.customId\n    };\n  });\n  return Promise.all(fileUploadPromises);\n};\nconst genUploader = initOpts => {\n  return (endpoint, opts) =>\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n  uploadFilesInternal(endpoint, {\n    ...opts,\n    url: resolveMaybeUrlArg(initOpts?.url),\n    package: initOpts.package\n  });\n};\nasync function uploadMultipart(file, presigned, opts) {\n  let etags;\n  let uploadedBytes = 0;\n  try {\n    etags = await Promise.all(presigned.urls.map(async (url, index) => {\n      const offset = presigned.chunkSize * index;\n      const end = Math.min(offset + presigned.chunkSize, file.size);\n      const chunk = file.slice(offset, end);\n      const etag = await uploadPartWithProgress({\n        url,\n        chunk: chunk,\n        contentDisposition: presigned.contentDisposition,\n        fileType: file.type,\n        fileName: file.name,\n        maxRetries: 10,\n        onProgress: delta => {\n          uploadedBytes += delta;\n          const percent = uploadedBytes / file.size * 100;\n          opts.onUploadProgress?.({\n            file: file.name,\n            progress: percent\n          });\n        }\n      });\n      return {\n        tag: etag,\n        partNumber: index + 1\n      };\n    }));\n  } catch (error) {\n    await opts.reportEventToUT(\"failure\", {\n      fileKey: presigned.key,\n      uploadId: presigned.uploadId,\n      fileName: file.name,\n      s3Error: error.toString()\n    });\n    throw \"unreachable\"; // failure event will throw for us\n  }\n  // Tell the server that the upload is complete\n  await opts.reportEventToUT(\"multipart-complete\", {\n    uploadId: presigned.uploadId,\n    fileKey: presigned.key,\n    etags\n  }).catch(res => {\n    console.log(\"Failed to alert UT of upload completion\");\n    throw new UploadThingError({\n      code: \"UPLOAD_FAILED\",\n      message: \"Failed to alert UT of upload completion\",\n      cause: res\n    });\n  });\n}\nasync function uploadPresignedPost(file, presigned, opts) {\n  const formData = new FormData();\n  Object.entries(presigned.fields).forEach(([k, v]) => formData.append(k, v));\n  formData.append(\"file\", file); // File data **MUST GO LAST**\n  const response = await new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open(\"POST\", presigned.url);\n    xhr.setRequestHeader(\"Accept\", \"application/xml\");\n    xhr.upload.onprogress = p => {\n      opts.onUploadProgress?.({\n        file: file.name,\n        progress: p.loaded / p.total * 100\n      });\n    };\n    xhr.onload = () => resolve({\n      status: xhr.status\n    });\n    xhr.onerror = e => reject(e);\n    xhr.send(formData);\n  }).catch(async error => {\n    await opts.reportEventToUT(\"failure\", {\n      fileKey: presigned.key,\n      uploadId: null,\n      fileName: file.name,\n      s3Error: error.toString()\n    });\n    throw \"unreachable\"; // failure event will throw for us\n  });\n\n  if (response.status > 299 || response.status < 200) {\n    await opts.reportEventToUT(\"failure\", {\n      fileKey: presigned.key,\n      uploadId: null,\n      fileName: file.name\n    });\n  }\n}\nexport { genUploader, version };","map":{"version":3,"names":["contentDisposition","UploadThingError","safeParseJSON","resolveMaybeUrlArg","withExponentialBackoff","generateClientDropzoneAccept","generateMimeTypes","generatePermittedFileTypes","version$1","maybeParseResponseXML","maybeXml","codeMatch","match","messageMatch","code","message","s3CodeToUploadThingCode","DEFAULT_ERROR_CODE","AccessDenied","EntityTooSmall","EntityTooLarge","ExpiredToken","IncorrectNumberOfFilesInPostRequest","InternalError","KeyTooLongError","MaxMessageLengthExceeded","uploadPartWithProgress","opts","retryCount","Promise","resolve","reject","xhr","XMLHttpRequest","open","url","setRequestHeader","fileType","fileName","onload","status","etag","getResponseHeader","maxRetries","delay","Math","pow","res","setTimeout","lastProgress","onerror","upload","onprogress","e","delta","loaded","onProgress","send","chunk","createAPIRequestUrl","config","URL","queryParams","URLSearchParams","search","set","actionType","slug","toString","createUTReporter","cfg","type","payload","endpoint","customHeaders","headers","response","fetch","method","body","JSON","stringify","package","p","parsed","s3Error","cause","ok","error","fromResponse","jsonOrError","Error","version","uploadFilesInternal","globalThis","bind","reportEventToUT","String","s3ConnectionRes","input","files","map","f","name","size","Array","isArray","fileUploadPromises","presigned","file","find","console","join","onUploadBegin","uploadMultipart","r","uploadPresignedPost","serverData","skipPolling","pollingUrl","authorization","pollingJwt","then","json","callbackData","undefined","key","customId","all","genUploader","initOpts","etags","uploadedBytes","urls","index","offset","chunkSize","end","min","slice","percent","onUploadProgress","progress","tag","partNumber","fileKey","uploadId","catch","log","formData","FormData","Object","entries","fields","forEach","k","v","append","total"],"sources":["D:/an3_facultate/sem1/IS/laboratoare/SocialApp-Fe/social-media-front/node_modules/uploadthing/client/index.js"],"sourcesContent":["import { contentDisposition, UploadThingError, safeParseJSON, resolveMaybeUrlArg, withExponentialBackoff } from '@uploadthing/shared';\nexport { generateClientDropzoneAccept, generateMimeTypes, generatePermittedFileTypes } from '@uploadthing/shared';\n\nvar version$1 = \"6.9.0\";\n\nconst maybeParseResponseXML = (maybeXml)=>{\n    const codeMatch = maybeXml.match(/<Code>(.*?)<\\/Code>/s);\n    const messageMatch = maybeXml.match(/<Message>(.*?)<\\/Message>/s);\n    const code = codeMatch?.[1];\n    const message = messageMatch?.[1];\n    if (!code || !message) return null;\n    return {\n        code: s3CodeToUploadThingCode[code] ?? DEFAULT_ERROR_CODE,\n        message\n    };\n};\n/**\n * Map S3 error codes to UploadThing error codes\n *\n * This is a subset of the S3 error codes, based on what seemed most likely to\n * occur in uploadthing. For a full list of S3 error codes, see:\n * https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html\n */ const DEFAULT_ERROR_CODE = \"UPLOAD_FAILED\";\nconst s3CodeToUploadThingCode = {\n    AccessDenied: \"FORBIDDEN\",\n    EntityTooSmall: \"TOO_SMALL\",\n    EntityTooLarge: \"TOO_LARGE\",\n    ExpiredToken: \"FORBIDDEN\",\n    IncorrectNumberOfFilesInPostRequest: \"TOO_MANY_FILES\",\n    InternalError: \"INTERNAL_SERVER_ERROR\",\n    KeyTooLongError: \"KEY_TOO_LONG\",\n    MaxMessageLengthExceeded: \"TOO_LARGE\"\n};\n\n/**\n * Used by client uploads where progress is needed.\n * Uses XMLHttpRequest.\n */ async function uploadPartWithProgress(opts, retryCount = 0) {\n    return new Promise((resolve, reject)=>{\n        const xhr = new XMLHttpRequest();\n        xhr.open(\"PUT\", opts.url, true);\n        xhr.setRequestHeader(\"Content-Type\", opts.fileType);\n        xhr.setRequestHeader(\"Content-Disposition\", contentDisposition(opts.contentDisposition, opts.fileName));\n        xhr.onload = async ()=>{\n            if (xhr.status >= 200 && xhr.status < 300) {\n                const etag = xhr.getResponseHeader(\"Etag\");\n                etag ? resolve(etag) : reject(\"NO ETAG\");\n            } else if (retryCount < opts.maxRetries) {\n                // Add a delay before retrying (exponential backoff can be used)\n                const delay = Math.pow(2, retryCount) * 1000;\n                await new Promise((res)=>setTimeout(res, delay));\n                resolve(await uploadPartWithProgress(opts, retryCount + 1)); // Retry the request\n            } else {\n                reject(\"Max retries exceeded\");\n            }\n        };\n        let lastProgress = 0;\n        xhr.onerror = async ()=>{\n            lastProgress = 0;\n            if (retryCount < opts.maxRetries) {\n                // Add a delay before retrying (exponential backoff can be used)\n                const delay = Math.pow(2, retryCount) * 100;\n                await new Promise((res)=>setTimeout(res, delay));\n                await uploadPartWithProgress(opts, retryCount + 1); // Retry the request\n            } else {\n                reject(\"Max retries exceeded\");\n            }\n        };\n        xhr.upload.onprogress = (e)=>{\n            const delta = e.loaded - lastProgress;\n            lastProgress += delta;\n            opts.onProgress(delta);\n        };\n        xhr.send(opts.chunk);\n    });\n}\n\nconst createAPIRequestUrl = (config)=>{\n    const url = new URL(config.url);\n    const queryParams = new URLSearchParams(url.search);\n    queryParams.set(\"actionType\", config.actionType);\n    queryParams.set(\"slug\", config.slug);\n    url.search = queryParams.toString();\n    return url;\n};\n/**\n * Creates a \"client\" for reporting events to the UploadThing server via the user's API endpoint.\n * Events are handled in \"./handler.ts starting at L200\"\n */ const createUTReporter = (cfg)=>{\n    return async (type, payload)=>{\n        const url = createAPIRequestUrl({\n            url: cfg.url,\n            slug: cfg.endpoint,\n            actionType: type\n        });\n        let customHeaders = typeof cfg.headers === \"function\" ? cfg.headers() : cfg.headers;\n        if (customHeaders instanceof Promise) customHeaders = await customHeaders;\n        const response = await cfg.fetch(url, {\n            method: \"POST\",\n            body: JSON.stringify(payload),\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"x-uploadthing-package\": cfg.package,\n                \"x-uploadthing-version\": version$1,\n                ...customHeaders\n            }\n        });\n        switch(type){\n            case \"failure\":\n                {\n                    // why isn't this narrowed automatically?\n                    const p = payload;\n                    const parsed = maybeParseResponseXML(p.s3Error ?? \"\");\n                    if (parsed?.message) {\n                        throw new UploadThingError({\n                            code: parsed.code,\n                            message: parsed.message\n                        });\n                    } else {\n                        throw new UploadThingError({\n                            code: \"UPLOAD_FAILED\",\n                            message: `Failed to upload file ${p.fileName} to S3`,\n                            cause: p.s3Error\n                        });\n                    }\n                }\n        }\n        if (!response.ok) {\n            const error = await UploadThingError.fromResponse(response);\n            throw error;\n        }\n        const jsonOrError = await safeParseJSON(response);\n        if (jsonOrError instanceof Error) {\n            throw new UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: jsonOrError.message,\n                cause: response\n            });\n        }\n        return jsonOrError;\n    };\n};\n\n// Don't want to ship our logger to the client, keep size down\nconst version = version$1;\nconst uploadFilesInternal = async (endpoint, opts)=>{\n    // Fine to use global fetch in browser\n    const fetch = globalThis.fetch.bind(globalThis);\n    const reportEventToUT = createUTReporter({\n        endpoint: String(endpoint),\n        url: opts.url,\n        package: opts.package,\n        fetch,\n        headers: opts.headers\n    });\n    // Get presigned URL for S3 upload\n    const s3ConnectionRes = await reportEventToUT(\"upload\", {\n        input: \"input\" in opts ? opts.input : null,\n        files: opts.files.map((f)=>({\n                name: f.name,\n                size: f.size,\n                type: f.type\n            }))\n    });\n    if (!s3ConnectionRes || !Array.isArray(s3ConnectionRes)) {\n        throw new UploadThingError({\n            code: \"BAD_REQUEST\",\n            message: \"No URL. How did you even get here?\",\n            cause: s3ConnectionRes\n        });\n    }\n    const fileUploadPromises = s3ConnectionRes.map(async (presigned)=>{\n        const file = opts.files.find((f)=>f.name === presigned.fileName);\n        if (!file) {\n            console.error(\"No file found for presigned URL\", presigned);\n            throw new UploadThingError({\n                code: \"NOT_FOUND\",\n                message: \"No file found for presigned URL\",\n                cause: `Expected file with name ${presigned.fileName} but got '${opts.files.join(\",\")}'`\n            });\n        }\n        opts.onUploadBegin?.({\n            file: file.name\n        });\n        if (\"urls\" in presigned) {\n            await uploadMultipart(file, presigned, {\n                reportEventToUT,\n                ...opts\n            });\n            // wait a bit as it's unsreasonable to expect the server to be done by now\n            await new Promise((r)=>setTimeout(r, 750));\n        } else {\n            await uploadPresignedPost(file, presigned, {\n                reportEventToUT,\n                ...opts\n            });\n        }\n        let serverData = null;\n        if (!opts.skipPolling) {\n            serverData = await withExponentialBackoff(async ()=>{\n                const res = await fetch(presigned.pollingUrl, {\n                    headers: {\n                        authorization: presigned.pollingJwt\n                    }\n                }).then((r)=>r.json());\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return res.status === \"done\" ? res.callbackData : undefined;\n            });\n        }\n        return {\n            name: file.name,\n            size: file.size,\n            type: file.type,\n            key: presigned.key,\n            url: \"https://utfs.io/f/\" + presigned.key,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            serverData: serverData,\n            customId: presigned.customId\n        };\n    });\n    return Promise.all(fileUploadPromises);\n};\nconst genUploader = (initOpts)=>{\n    return (endpoint, opts)=>// eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        uploadFilesInternal(endpoint, {\n            ...opts,\n            url: resolveMaybeUrlArg(initOpts?.url),\n            package: initOpts.package\n        });\n};\nasync function uploadMultipart(file, presigned, opts) {\n    let etags;\n    let uploadedBytes = 0;\n    try {\n        etags = await Promise.all(presigned.urls.map(async (url, index)=>{\n            const offset = presigned.chunkSize * index;\n            const end = Math.min(offset + presigned.chunkSize, file.size);\n            const chunk = file.slice(offset, end);\n            const etag = await uploadPartWithProgress({\n                url,\n                chunk: chunk,\n                contentDisposition: presigned.contentDisposition,\n                fileType: file.type,\n                fileName: file.name,\n                maxRetries: 10,\n                onProgress: (delta)=>{\n                    uploadedBytes += delta;\n                    const percent = uploadedBytes / file.size * 100;\n                    opts.onUploadProgress?.({\n                        file: file.name,\n                        progress: percent\n                    });\n                }\n            });\n            return {\n                tag: etag,\n                partNumber: index + 1\n            };\n        }));\n    } catch (error) {\n        await opts.reportEventToUT(\"failure\", {\n            fileKey: presigned.key,\n            uploadId: presigned.uploadId,\n            fileName: file.name,\n            s3Error: error.toString()\n        });\n        throw \"unreachable\"; // failure event will throw for us\n    }\n    // Tell the server that the upload is complete\n    await opts.reportEventToUT(\"multipart-complete\", {\n        uploadId: presigned.uploadId,\n        fileKey: presigned.key,\n        etags\n    }).catch((res)=>{\n        console.log(\"Failed to alert UT of upload completion\");\n        throw new UploadThingError({\n            code: \"UPLOAD_FAILED\",\n            message: \"Failed to alert UT of upload completion\",\n            cause: res\n        });\n    });\n}\nasync function uploadPresignedPost(file, presigned, opts) {\n    const formData = new FormData();\n    Object.entries(presigned.fields).forEach(([k, v])=>formData.append(k, v));\n    formData.append(\"file\", file); // File data **MUST GO LAST**\n    const response = await new Promise((resolve, reject)=>{\n        const xhr = new XMLHttpRequest();\n        xhr.open(\"POST\", presigned.url);\n        xhr.setRequestHeader(\"Accept\", \"application/xml\");\n        xhr.upload.onprogress = (p)=>{\n            opts.onUploadProgress?.({\n                file: file.name,\n                progress: p.loaded / p.total * 100\n            });\n        };\n        xhr.onload = ()=>resolve({\n                status: xhr.status\n            });\n        xhr.onerror = (e)=>reject(e);\n        xhr.send(formData);\n    }).catch(async (error)=>{\n        await opts.reportEventToUT(\"failure\", {\n            fileKey: presigned.key,\n            uploadId: null,\n            fileName: file.name,\n            s3Error: error.toString()\n        });\n        throw \"unreachable\"; // failure event will throw for us\n    });\n    if (response.status > 299 || response.status < 200) {\n        await opts.reportEventToUT(\"failure\", {\n            fileKey: presigned.key,\n            uploadId: null,\n            fileName: file.name\n        });\n    }\n}\n\nexport { genUploader, version };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}